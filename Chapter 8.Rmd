---
title: "Chapter 8"
author: "Jorge Mendes"
date: "20/08/2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Chapter 8

# Quiz

1 - What are the three most important types of condition?

```{r}
#messages, errors and warnings.
```

2 - What function do you use to ignore errors in block of code?

```{r}
?tryCatch
```

3 - What’s the main difference between tryCatch() and withCallingHandlers()?

```{r}
#tryCatch exits the code, making it good to work with errors, while withCallingHandlers dows not, and is good paired with warnings and messages.
```

4 - Why might you want to create a custom error object?

```{r}
#To give custom messages more useful to the user.
```

# Signalling conditions

1 - Write a wrapper around file.remove() that throws an error if the file to be deleted does not exist.

```{r}
check.file.remove <- function(...){
  if(!file.exists(...)) stop("File doesn't exist.")
  
  file.remove(...)
}

check.file.remove("dfghn")
```

2 - What does the appendLF argument to message() do? How is it related to cat()?

```{r}
?message
#it automatically adds a newline after messages.
#it works the same way as cat
```

# Handling Conditions

## Exercises

1 - What extra information does the condition generated by abort() contain compared to the condition generated by stop() i.e. what’s the difference between these two objects? Read the help for ?abort to learn more.

```{r}
catch_cnd(stop("An error"))
catch_cnd(abort("An error"))
#abort gives a call trace (I think this is a call stack)

?abort
#abort is stop with some functionalities to add more custom information. One of thes informations added by default it's a traceback.
```

2 - Predict the results of evaluating the following code

```{r}
show_condition <- function(code) {
  tryCatch(
    error = function(cnd) "error",
    warning = function(cnd) "warning",
    message = function(cnd) "message",
    {
      code
      NULL
    }
  )
}

show_condition(stop("!")) #error
show_condition(10) #NULL
show_condition(warning("?!")) #warning
show_condition({
  10
  message("?")
  warning("?!")
}) #message


```

3 - Explain the results of running this code:

```{r}
withCallingHandlers(
  message = function(cnd) message("b"),
  withCallingHandlers(
    message = function(cnd) message("a"),
    message("c")
  )
)
#> b #called when a is called
#> a #called when c is called 
#> b #called when c is called
#> c #called by the code

#the messages stack themselves when c is called.
```

4 - Read the source code for catch_cnd() and explain how it works.

```{r}
View(catch_cnd)
#It forces the execution of the error and captures the expression.
```

5 - How could you rewrite show_condition() to use a single handler?

```{r}
View(show_condition)
#remove the catch for other handlers and suppress them.
```

# Custom conditions

## Exercises

1 - Inside a package, it’s occasionally useful to check that a package is installed before using it. Write a function that checks if a package is installed (with requireNamespace("pkg", quietly = FALSE)) and if not, throws a custom condition that includes the package name in the metadata.

```{r}
check_packages <- function(package){
  
  if(!requireNamespace(package, quietly = FALSE)){
    abort(glue::glue("Package {package} not found"), package_name = package)
    }
}

check_packages("dply")
```

2 - Inside a package you often need to stop with an error when something is not right. Other packages that depend on your package might be tempted to check these errors in their unit tests. How could you help these packages to avoid relying on the error message which is part of the user interface rather than the API and might change without notice?

```{r}
#I could make the messages in a programmable way, so they can't use the text of the errors. Also I could create error objects with useful metadata to help in tests.
```

